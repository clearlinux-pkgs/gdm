From 67eef90d3d2c1b8455976ad1a9c9ffc2e4ced453 Mon Sep 17 00:00:00 2001
From: Ray Strode <rstrode@redhat.com>
Date: Wed, 20 Sep 2017 12:02:38 -0400
Subject: [PATCH] session-worker: only jump to VT on seat0

seat0 is the only seat that supports VTs, so don't ever try to
change VTs if not on seat0.
---
 daemon/gdm-session-worker.c | 12 ++++++++----
 1 file changed, 8 insertions(+), 4 deletions(-)

diff --git a/daemon/gdm-session-worker.c b/daemon/gdm-session-worker.c
index c4d21ec8..543006ba 100644
--- a/daemon/gdm-session-worker.c
+++ b/daemon/gdm-session-worker.c
@@ -882,62 +882,64 @@ jump_to_vt (GdmSessionWorker  *worker,
 
 static void
 gdm_session_worker_uninitialize_pam (GdmSessionWorker *worker,
                                      int               status)
 {
         g_debug ("GdmSessionWorker: uninitializing PAM");
 
         if (worker->priv->pam_handle == NULL)
                 return;
 
         gdm_session_worker_get_username (worker, NULL);
 
         if (worker->priv->state >= GDM_SESSION_WORKER_STATE_SESSION_OPENED) {
                 pam_close_session (worker->priv->pam_handle, 0);
                 gdm_session_auditor_report_logout (worker->priv->auditor);
         } else {
                 gdm_session_auditor_report_login_failure (worker->priv->auditor,
                                                           status,
                                                           pam_strerror (worker->priv->pam_handle, status));
         }
 
         if (worker->priv->state >= GDM_SESSION_WORKER_STATE_ACCREDITED) {
                 pam_setcred (worker->priv->pam_handle, PAM_DELETE_CRED);
         }
 
         pam_end (worker->priv->pam_handle, status);
         worker->priv->pam_handle = NULL;
 
         gdm_session_worker_stop_auditor (worker);
 
-        if (worker->priv->login_vt != worker->priv->session_vt) {
-                jump_to_vt (worker, worker->priv->login_vt);
+        if (g_strcmp0 (worker->priv->display_seat_id, "seat0") == 0) {
+                if (worker->priv->login_vt != worker->priv->session_vt) {
+                        jump_to_vt (worker, worker->priv->login_vt);
+                }
         }
 
         worker->priv->login_vt = 0;
         worker->priv->session_vt = 0;
 
         g_debug ("GdmSessionWorker: state NONE");
         worker->priv->state = GDM_SESSION_WORKER_STATE_NONE;
 }
 
 static char *
 _get_tty_for_pam (const char *x11_display_name,
                   const char *display_device)
 {
 #ifdef __sun
         return g_strdup (display_device);
 #else
         return g_strdup (x11_display_name);
 #endif
 }
 
 #ifdef PAM_XAUTHDATA
 static struct pam_xauth_data *
 _get_xauth_for_pam (const char *x11_authority_file)
 {
         FILE                  *fh;
         Xauth                 *auth = NULL;
         struct pam_xauth_data *retval = NULL;
         gsize                  len = sizeof (*retval) + 1;
 
         fh = fopen (x11_authority_file, "r");
@@ -1825,62 +1827,64 @@ out:
         if (fd < 0) {
                 g_warning ("unable to log session");
                 fd = g_open ("/dev/null", O_RDWR);
         }
 
         return fd;
 }
 
 static gboolean
 gdm_session_worker_start_session (GdmSessionWorker  *worker,
                                   GError           **error)
 {
         struct passwd *passwd_entry;
         pid_t session_pid;
         int   error_code;
 
         gdm_get_pwent_for_name (worker->priv->username, &passwd_entry);
         if (worker->priv->is_program_session) {
                 g_debug ("GdmSessionWorker: opening session for program '%s'",
                          worker->priv->arguments[0]);
         } else {
                 g_debug ("GdmSessionWorker: opening user session with program '%s'",
                          worker->priv->arguments[0]);
         }
 
         error_code = PAM_SUCCESS;
 
         /* If we're in new vt mode, jump to the new vt now. There's no need to jump for
          * the other two modes: in the logind case, the session will activate itself when
          * ready, and in the reuse server case, we're already on the correct VT. */
-        if (worker->priv->display_mode == GDM_SESSION_DISPLAY_MODE_NEW_VT) {
-                jump_to_vt (worker, worker->priv->session_vt);
+        if (g_strcmp0 (worker->priv->display_seat_id, "seat0") == 0) {
+                if (worker->priv->display_mode == GDM_SESSION_DISPLAY_MODE_NEW_VT) {
+                        jump_to_vt (worker, worker->priv->session_vt);
+                }
         }
 
         if (!worker->priv->is_program_session && !run_script (worker, GDMCONFDIR "/PostLogin")) {
                 g_set_error (error,
                              GDM_SESSION_WORKER_ERROR,
                              GDM_SESSION_WORKER_ERROR_OPENING_SESSION,
                              "Failed to execute PostLogin script");
                 error_code = PAM_ABORT;
                 goto out;
         }
 
         if (!worker->priv->is_program_session && !run_script (worker, GDMCONFDIR "/PreSession")) {
                 g_set_error (error,
                              GDM_SESSION_WORKER_ERROR,
                              GDM_SESSION_WORKER_ERROR_OPENING_SESSION,
                              "Failed to execute PreSession script");
                 error_code = PAM_ABORT;
                 goto out;
         }
 
         session_pid = fork ();
 
         if (session_pid < 0) {
                 g_set_error (error,
                              GDM_SESSION_WORKER_ERROR,
                              GDM_SESSION_WORKER_ERROR_OPENING_SESSION,
                              "%s", g_strerror (errno));
                 error_code = PAM_ABORT;
                 goto out;
         }
-- 
2.14.1

